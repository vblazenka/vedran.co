<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vedran Bla≈æenka - Software Developer</title>

    <link rel="stylesheet" href="../src/styles/styles.css">
    <link rel="stylesheet" href="../src/styles/blog.css">
    <link rel="preload" href="../src/styles/prism.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
</head>

<body class="Blog">
    <header>
        <div class="navigation">
            <a href="../index.html">üëà Go back</a>
        </div>
    </header>

    <main class="post">
<h1 id="monkeypatching">Monkey patching</h1>
<p>Monkey patching is a powerful yet controversial technique in programming, often used to modify or extend the functionality of an object, method, or class at runtime. While it's a convenient solution for handling third-party library inconsistencies or performing unit testing, it should be used judiciously due to the potential for introducing subtle bugs or making your code more difficult to understand and maintain.</p>
<p>The name "monkey patching" comes from the phrase "monkey with", meaning to tamper or fiddle with something. In programming, you are essentially "tampering with" or changing parts of a module or class without altering the original source code.</p>
<p>To illustrate this, consider a situation where you want to add logging functionality to the 'add' method of a math library:</p>
<pre><code class="javascript language-javascript">import MathLib from 'mathlib';

const mathLib = new MathLib();
const res = mathLib.add(2, 3);

// we can keep original implementation if we want to
// restore original implementation later on
// const originalAdd = mathLib.add;

// Let's override (monkey patch) original add
// method and replace it with our own implementation
// that supports logging
mathLib.add = function(a, b) {
    console.log(`You are adding ${a} and ${b}.`);
    return a + b;
}
</code></pre>
<p>This example illustrates the flexibility of monkey patching. Without having access to the source code of 'MathLib', we are able to introduce new behavior (logging) to an existing method.</p>
<p>üëç <strong>Pros:</strong></p>
<ul>
<li><strong>Useful for mocking during unit testing:</strong> Some testing libraries leverage monkey patching to replace methods with mock versions that make testing more isolated and predictable.</li>
<li><strong>Bypassing bugs in third-party code:</strong> If there's a bug in a library you don't control, you could monkey patch a fix without waiting for the library maintainers to update it.</li>
<li><strong>Dynamic behavior changes:</strong> Monkey patching can be used to add or change the behavior of objects at runtime, such as logging, profiling, or other runtime analysis.</li>
</ul>
<p>üëé <strong>Cons:</strong></p>
<ul>
<li><strong>Code discrepancy:</strong> Monkey patching creates a discrepancy between the original source code and the observable behavior in the written code, which can lead to confusion for other developers.</li>
<li><strong>Debugging complexity:</strong> It can be hard to trace or debug issues due to the discrepancy mentioned above. When the behavior of methods isn't what's expected based on the source code, it can take a long time to realize that a monkey patch is the cause.</li>
<li><strong>Maintenance issues:</strong> If the underlying library changes, your monkey patches might break or start to exhibit unexpected behavior.
Namespace clashes: If two pieces of code monkey patch the same method but aren't aware of each other, they may interfere with each other, causing unexpected behavior or bugs.</li>
</ul>
<p>The technique is often considered a 'hack' or a 'kludge', and as such, many developers advise to use it sparingly, if at all. It's important to remember that the better the design of your codebase is, the less likely you'll need to rely on techniques like monkey patching. When you do need to use it, be sure to document your code thoroughly to help maintain readability and ease of debugging.</p>
<h2 id="practicetime">Practice time</h2>
<ul>
<li>What is monkey patching?</li>
<li>What are some scenarios where you could use monkey patching?</li>
<li>What are the downsides of using monkey patching?</li>
</ul>
    </main>

    <script src="../src/scripts/prism.js"></script>
    <noscript>
        <link rel="stylesheet" href="../src/styles/prism.css">
    </noscript>
</body>

</html>